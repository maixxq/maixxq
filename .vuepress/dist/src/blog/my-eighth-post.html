<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Data Structure &amp; Algo - Binary Search</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.02edf1fd.css" as="style"><link rel="preload" href="/assets/js/app.90976eed.js" as="script"><link rel="preload" href="/assets/js/2.861e931a.js" as="script"><link rel="preload" href="/assets/js/13.e9f96185.js" as="script"><link rel="prefetch" href="/assets/js/10.d9a6f23c.js"><link rel="prefetch" href="/assets/js/11.bef298db.js"><link rel="prefetch" href="/assets/js/12.efb01f17.js"><link rel="prefetch" href="/assets/js/14.fe54f414.js"><link rel="prefetch" href="/assets/js/15.2974fe7a.js"><link rel="prefetch" href="/assets/js/16.38708b8d.js"><link rel="prefetch" href="/assets/js/17.4850a87d.js"><link rel="prefetch" href="/assets/js/18.44f911cb.js"><link rel="prefetch" href="/assets/js/19.85461c2d.js"><link rel="prefetch" href="/assets/js/20.a94d2ab5.js"><link rel="prefetch" href="/assets/js/21.c0deb5f6.js"><link rel="prefetch" href="/assets/js/22.80e8a88d.js"><link rel="prefetch" href="/assets/js/23.d6f67f6e.js"><link rel="prefetch" href="/assets/js/3.5b6889f5.js"><link rel="prefetch" href="/assets/js/4.0ac3e95f.js"><link rel="prefetch" href="/assets/js/5.7ae9ceff.js"><link rel="prefetch" href="/assets/js/6.5475fba6.js"><link rel="prefetch" href="/assets/js/7.d4f11875.js"><link rel="prefetch" href="/assets/js/8.d46e131a.js"><link rel="prefetch" href="/assets/js/9.11ead18e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.02edf1fd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!---->  <!----> </div> <div class="page"> <div class="content__default"><meta name="viewport" content="width=device-width, initial-scale=1"> <p>Binary search is an effective algorithm for searching a target element in a <strong>sorted</strong> array. It does so by always dividing the list of items into half and compare the position of the target value with the middle element. Elements need to be sorted first if it is not in order. The implementation of this search algorithm can be made in the iterative method or the recursive method.</p> <div class="language-js extra-class"><pre class="language-js"><code>int <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token parameter">int arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>int left<span class="token punctuation">,</span>int right<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    int n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    int left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    int right <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//prevent integer overflow</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> target<span class="token punctuation">;</span>
        <span class="token function">elseif</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//search between the mid to right</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//search between left to mid</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// can't find target</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="demo-of-binary-search"><a href="#demo-of-binary-search" class="header-anchor">#</a> Demo of Binary Search</h2> <h4 id="time-complexity-o-log-n"><a href="#time-complexity-o-log-n" class="header-anchor">#</a> Time Complexity: O(log n)</h4> <h4 id="space-complexity-o-1"><a href="#space-complexity-o-1" class="header-anchor">#</a> Space Complexity: O(1)</h4> <p>Given a sorted array [ 0, 1, 2, 3, 5, 7, 9] and our target element is 7, we first find the middle element by diving the array into two. Identifying 3 as the middle element, we have the left interval [0, 1, 2] and the right interval [5, 7, 9]. The sorted array (in ascending order) ensures elements in left interval are all smaller than the middle element while the elements in the right interval are all bigger than the middle element.</p> <img src="/binary_search_0.png" width="600em" height="220em"> <p>Next, we compare the target element 7 with the middle element 3. Since 7 is larger than 3, we can discard the left interval entirely and search the target value in the right interval. Then we repeat the process after updating the lower bound (middle element) of the right interval by one index.</p> <img src="/binary_search_1.png" width="600em" height="220em"> <p>This leads to the search in interval [5, 7, 9] and we return the mid element 7 as it is equal to the target value.</p> <img src="/binary_search_2.png" width="600em" height="280em"> <h3 id="leetcode-33-search-in-rotated-sorted-array-no-duplicates"><a href="#leetcode-33-search-in-rotated-sorted-array-no-duplicates" class="header-anchor">#</a> Leetcode 33. Search in Rotated Sorted Array (no duplicates)</h3> <p>An array given was originally sorted in ascending order. However, it has been pivoted at an element, generating a new array that is partially sorted in two parts. Our goal is to find the target element in the new pivoted array in O(log n) time. If the target value is not found, return -1. Without pivoting, this is a typical question that can be solved with binary search algorithm.</p> <p>The brute force solution ignoring the time constraint will simply be iterating each elements in the array size of n with time complexity of O(n). However, let's stick to the rules of the game and solved it in the time required.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token punctuation">:</span>
    int <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">vector<span class="token operator">&lt;</span>int<span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> int target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        int low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        int high <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">//modified binary search to find the pivot</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            int mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token comment">//can change to (low + (high-low))/2 to prevent integer overflow</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&gt;</span>nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                low <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                high <span class="token operator">=</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        int begin <span class="token operator">=</span> low<span class="token punctuation">;</span>
        low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        high <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        
        <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">&gt;=</span>nums<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>target<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            low <span class="token operator">=</span> begin<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            high <span class="token operator">=</span> begin<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// original binary search </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>
            int mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
                low <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>First, we can locate the smallest element in the array. Since the smallest element is the pivot point, we know that both left and right side of the smallest element will be arraged in ascending order. With this in mind, the first while loop is set to find the smallest element. Observed that the smallest element is always named as the left bounded variable.</p> <img src="/binary_search_3.png" width="800rem" height="650rem"> <p>Once the smallest element in the array is found, a variable <code>int begin = left</code> is created to indicate the starting index of smallest element. Next, left and right boundary are reset again with the new variable <code>begin</code> in the array. Two sorted arrays can be seen from left to begin and from begin to right. Now, original binary search can be conducted after we compare target value to the value in the <code>begin</code> index. If target value is bigeer than the nums[begin] and smaller than nums[right], we shift left boundary to begin and binary search on the right side. Else, we shift the right boundary to begin and search on the left side. As such, the target value will be returned in O(log n) time.</p> <img src="/binary_search_4.png" width="700rem" height="650rem"> <h3 id="notes"><a href="#notes" class="header-anchor">#</a> Notes</h3> <p>This is my first time dissecting a leetcode problem and solution step by step to ensure that I know exactly what each line of codes is doing. I hope this post can help someone to understand the solution better by the visualization. It was indeed a challenging task to thoroughly comprehend the solution even though the solution is short. Sometimes when we watch or read a tutorial on coding question, there is a tendency to think that we understand the solution. I admit I often fall into this rabbit hole and so this is a good start to improve my coding.</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.90976eed.js" defer></script><script src="/assets/js/2.861e931a.js" defer></script><script src="/assets/js/13.e9f96185.js" defer></script>
  </body>
</html>
